# -*- coding: utf-8 -*-
"""2_elements.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Uwj_hkO67jW4cYa9UbY5yDsxb4WbHeHP
"""

import sympy as sp
import matplotlib.pyplot as plt
import numpy as np

Q, x, L, E, xi = sp.symbols('Q, x, L,E, xi')

# SYMBOLIC PLOTTING

def Sym_plot(expr, x0, xf, step, fase,color = None, **params):
  expr_func = sp.lambdify((x, *params.keys()), expr, 'numpy')

  x_values = np.linspace(x0, xf, step)
  y_values = np.array(expr_func(x_values, *params.values()))
  if y_values.ndim == 0 or y_values.shape == (1,):
      y_values = np.full_like(x_values, y_values)

  if color is None:
      plt.plot(x_values + fase, y_values)              # sin color → usa el default
  else:
      plt.plot(x_values + fase, y_values, color=color) # con color → usa el elegido
  plt.grid(True)

# LOAD DEFFINITION ---------------------------------------------
q0 = 0
q1 = -Q/(3*L/4)*x + Q/3
q2 = -Q/(3*L/4)*x + Q/3
q3 = Q/(L/2)*x -Q

q = [q0,q1,q2,q3]
total_load = -5*L*Q/(8)

# DOF DEFINITION ------------------------------------------------
element_dof_index = sp.Matrix([[0,1,2,3],[2,3,4,5]])

f_dof_index = [3,5]
r_dof_index = [0,1,2,4]

dof_number = 6
f_dof_number = 2
r_dof_number = 4

# ELEMENT DEFINITION ---------------------------------------------

section_lengths = [L/4,L/2,L/4,L/2,L]

# INERTIA FUNCTION DEFINITION -------------------------------------

def inertia(r):
  return(sp.pi/4 * r**4)

def radius(initial_D,final_D,Length):
  return(  ((final_D/2)-(initial_D/2))/(Length) *x  +  initial_D/2)

# sector 0
r0_x = radius(L/20,L/40,L/4)
i0_x = inertia(r0_x)

#sector 1
r1_x = radius(L/40,L/40,L/2)
i1_x = inertia(r1_x) .subs(x,x-(L/4))

#sector 2
r2_x = radius(L/40,L/20,L/4)
i2_x = inertia(r2_x) .subs(x,x-(3*L/4))

#sector 3
r3_x = radius(L/20,L/40,L)
i3_x = inertia(r3_x)

i0_x.subs({L:1,x:1})

fac = 1
plt.figure(figsize=(10*fac,5*fac))
plt.title("Inertia sections")
plt.xlabel("x")
plt.ylabel("$I(x)$")

Sym_plot(i0_x,0,0.25,30,0,L=1)
Sym_plot(i1_x,0.25,0.75,30,0,L=1)
Sym_plot(i2_x,0.75,1,30,0,L=1)
Sym_plot(i3_x,0,1,30,1,L=1)
plt.legend(['sector 0','sector 1','sector 2','sector 3'])


plt.axvline(x=1, color='k', linestyle='dotted')
plt.axvline(x=2, color='k', linestyle='dotted')
plt.axvline(x=0, color='k', linestyle='dotted')

plt.axvline(x=0.25, color='gray', linestyle='dashed')
plt.axvline(x=0.75, color='gray', linestyle='dashed')

"""# CASE SOLUTION"""

# INTEGRAL FORMS
integral_forms = []

#SECTOR 0 -------------------------------------------------
I3_0 = sp.integrate(x/(E*i0_x),(x,0,x))
I4_0 = sp.integrate(1/(E*i0_x),(x,0,x))
I2_0 = sp.integrate(I4_0,(x,0,x))
I1_0 = sp.integrate(I3_0,(x,0,x))

integral_forms.append(sp.Matrix([I1_0,I2_0,I3_0,I4_0]))

#SECTOR 1 -------------------------------------------------

I3_1 = sp.integrate(x/(E*i1_x),(x,L/4,x)) + I3_0.subs(x,L/4)
I4_1 = sp.integrate(1/(E*i1_x),(x,L/4,x)) + I4_0.subs(x,L/4)

I2_1 = sp.integrate(I4_1,(x,L/4,x)) + I2_0.subs(x,L/4)
I1_1 = sp.integrate(I3_1,(x,L/4,x)) + I1_0.subs(x,L/4)

integral_forms.append(sp.Matrix([I1_1,I2_1,I3_1,I4_1]))

#SECTOR 2 -------------------------------------------------

I3_2 = sp.integrate(x/(E*i2_x),(x,3*L/4,x)) + I3_1.subs(x,3*L/4)
I4_2 = sp.integrate(1/(E*i2_x),(x,3*L/4,x)) + I4_1.subs(x,3*L/4)

I2_2 = sp.integrate(I4_2,(x,3*L/4,x)) + I2_1.subs(x,3*L/4)
I1_2 = sp.integrate(I3_2,(x,3*L/4,x)) + I1_1.subs(x,3*L/4)

integral_forms.append(sp.Matrix([I1_2,I2_2,I3_2,I4_2]))


#SECTOR 3 --------------------------------------------------

I3_3 = sp.integrate(x/(E*i3_x),(x,0,x))
I4_3 = sp.integrate(1/(E*i3_x),(x,0,x))
I2_3 = sp.integrate(I4_3,(x,0,x))
I1_3 = sp.integrate(I3_3,(x,0,x))

integral_forms.append(sp.Matrix([I1_3,I2_3,I3_3,I4_3]))

fac = 1
plt.figure(figsize=(10*fac,5*fac))
plt.title("Inertia sections")
plt.xlabel("x")
plt.ylabel("$I(x)$")

for f in range(4):
  Sym_plot(integral_forms[0][f],0,0.25,30,0,L=1,E=1)

for f in range(4):
  Sym_plot(integral_forms[1][f],0.25,0.75,30,0,L=1,E=1)

for f in range(4):
  Sym_plot(integral_forms[2][f],0.75,1,30,0,L=1,E=1)

for f in range(4):
  Sym_plot(integral_forms[3][f],0,1,30,1,L=1,E=1)


plt.axvline(x=1, color='k', linestyle='dotted')
plt.axvline(x=2, color='k', linestyle='dotted')
plt.axvline(x=0, color='k', linestyle='dotted')

plt.axvline(x=0.25, color='gray', linestyle='dashed')
plt.axvline(x=0.75, color='gray', linestyle='dashed')

# SHAPE FUNCTIONS ELEMENT 0-----------------------------------------------------

E_shapeFunctions = []

for t in range(4):

  i1,i2,i3,i4 = integral_forms[t]

  if t == 3:
    i1_l,i2_l,i3_l,i4_l = integral_forms[-1].subs(x,L)

  else:
    i1_l,i2_l,i3_l,i4_l = integral_forms[2].subs(x,L)

  den = (i1_l*i4_l) - (i2_l*i3_l)

  psi2 = (-i4_l*i1 + i3_l*i2)/den + 1

  psi3 = ((i2_l - i4_l*L)*i1 + (-i1_l + i3_l*L)*i2)/den + x

  psi5 = (i4_l*i1 -i3_l*i2)/den

  psi6 = (-i2_l*i1 + i1_l*i2)/den

  E_shapeFunctions.append(sp.Matrix([psi2,psi3,psi5,psi6]).applyfunc(sp.simplify))


fac = 1
plt.figure(figsize=(10*fac,5*fac))
colors = ['teal','indigo','olivedrab','royalblue']

for i in range(4):
  Sym_plot(E_shapeFunctions[0][i],0,0.25,50,0,L=1.0,E=1.0, color=colors[i])

for i in range(4):
  Sym_plot(E_shapeFunctions[1][i],0.25,0.75,50,0,L=1.0,E=1.0, color=colors[i])

for i in range(4):
  Sym_plot(E_shapeFunctions[2][i],0.75,1,50,0,L=1.0,E=1.0, color=colors[i])

for i in range(4):
  Sym_plot(E_shapeFunctions[3][i],0,1,50,1,L=1.0,E=1.0, color=colors[i])

plt.legend([r"$\psi_2(x)$", r"$\psi_3(x)$", r"$\psi_5(x)$", r"$\psi_6(x)$"])

plt.axvline(x=1, color='k', linestyle='dotted')
plt.axvline(x=2, color='k', linestyle='dotted')
plt.axvline(x=0, color='k', linestyle='dotted')

plt.axvline(x=0.25, color='gray', linestyle='dashed')
plt.axvline(x=0.75, color='gray', linestyle='dashed')


plt.title(r"System shape functions")
plt.xlabel(r"$x$")
plt.ylabel(r"$\psi_i(x)$")

# STINFNESS MATRIX

#element 0------------------------------------------------
i1,i2,i3,i4 = integral_forms[2]

i1 = i1.subs(x,L)
i2 = i2.subs(x,L)
i3 = i3.subs(x,L)
i4 = i4.subs(x,L)

den = (i1*i4 - i2*i3)

k22 = -i4/den
k55 = k22
k25 = -k22
k52 = -k22

k23 = -i3/den
k32 = k23
k35 = -k23
k53 = -k23

k26 = -i2/den
k62 = k26
k65 = -k26
k56 = -k26

k33 = (i1-i3*L)/den

k36 = -i1/den
k63 = k36

k66 = (i1-i2*L)/den

k0 = sp.Matrix([[k22,k23,k25,k26],[k32,k33,k35,k36],[k52,k53,k55,k56],[k62,k63,k65,k66]])

# element 1 --------------------------------------------------------------------
i1,i2,i3,i4 = integral_forms[-1]

i1 = i1.subs(x,L)
i2 = i2.subs(x,L)
i3 = i3.subs(x,L)
i4 = i4.subs(x,L)

den = (i1*i4 - i2*i3)

k22 = -i4/den
k55 = k22
k25 = -k22
k52 = -k22

k23 = -i3/den
k32 = k23
k35 = -k23
k53 = -k23

k26 = -i2/den
k62 = k26
k65 = -k26
k56 = -k26

k33 = (i1-i3*L)/den

k36 = -i1/den
k63 = k36

k66 = (i1-i2*L)/den

k1 = sp.Matrix([[k22,k23,k25,k26],[k32,k33,k35,k36],[k52,k53,k55,k56],[k62,k63,k65,k66]])

# GLOBAL ASSEMBLY =============================================================

# global stifness matrix assembly
element_dof_index = sp.Matrix([[0,1,2,3],[2,3,4,5]])
K = sp.zeros(dof_number,dof_number)

for e in range(2):
  dof = element_dof_index[e,:]
  for i in range(4): # every row
    for  j in range(4): # every column

      # direction of assembly in the global matrix (corresponding dof)
      row_idx = dof[i]
      col_idx = dof[j]

      # adition of the local value in the global position
      if e==0:
        K[row_idx,col_idx] += k0[i,j]
      elif e == 1:
        K[row_idx,col_idx] += k1[i,j]

# Nodal equivalen loads

p_0 = []

#sector 0:

#sector 1:
sector = 1
fi = sp.integrate(E_shapeFunctions[sector][0]*q[sector],(x,L/4,3*L/4))
mi = sp.integrate(E_shapeFunctions[sector][1]*q[sector],(x,L/4,3*L/4))
fj = sp.integrate(E_shapeFunctions[sector][2]*q[sector],(x,L/4,3*L/4))
mj = sp.integrate(E_shapeFunctions[sector][3]*q[sector],(x,L/4,3*L/4))

p_0.append(sp.Matrix([fi,mi,fj,mj]))

#sector 2:
sector = 2
fi = sp.integrate(E_shapeFunctions[sector][0]*q[sector],(x,3*L/4,L))
mi = sp.integrate(E_shapeFunctions[sector][1]*q[sector],(x,3*L/4,L))
fj = sp.integrate(E_shapeFunctions[sector][2]*q[sector],(x,3*L/4,L))
mj = sp.integrate(E_shapeFunctions[sector][3]*q[sector],(x,3*L/4,L))

p_0.append(sp.Matrix([fi,mi,fj,mj]))
p_0 = p_0[1] + p_0[0]

p_1 = []
#sector 3:
sector = 3
fi = sp.integrate(E_shapeFunctions[sector][0]*q[sector],(x,0,L/2))
mi = sp.integrate(E_shapeFunctions[sector][1]*q[sector],(x,0,L/2))
fj = sp.integrate(E_shapeFunctions[sector][2]*q[sector],(x,0,L/2))
mj = sp.integrate(E_shapeFunctions[sector][3]*q[sector],(x,0,L/2))

p_1.append(sp.Matrix([fi,mi,fj,mj]))
p_1 = p_1[0]

#nodal equivalent load vector assembly
P = sp.zeros(dof_number,1)

for i,idx in enumerate(element_dof_index[0,:]):
  P[idx] += sp.factor(p_0[i])

for i,idx in enumerate(element_dof_index[1,:]):
  P[idx] += sp.factor(p_1[i])

total_equivalentLoad = (P[0]+P[2]+P[4]).subs({L:1,Q:1})


if total_equivalentLoad == total_load.subs({L:1,Q:1}):

  display('✅ Vertical equivalent loads ARE equal to the total vetical load')
else:
  display('❌ Vertical equivalent loads ARE NOT equal to the total vertical load')

F = sp.zeros(dof_number,1)

# REDUCED SYSTEM EXTRACTION
f_dof = f_dof_index
r_dof = r_dof_index

Kff = K.extract(f_dof,f_dof)
Kfr = K.extract(f_dof,r_dof)
Krf = K.extract(r_dof,f_dof)
Krr = K.extract(r_dof,r_dof)



Pf = P.extract(f_dof,[0])
Pr = P.extract(r_dof,[0])

# SYSTEM SOLUTION
Uf = Kff.inv() * Pf
Fr = Krf @ Uf - Pr

# NODAL DISPLACEMENTS
U = sp.zeros(dof_number,1)
for i,idx in enumerate(f_dof):
  U[idx,0] = Uf[i,0]

display(U.applyfunc(sp.N))

# NODAL FORCES
F_sol = sp.zeros(dof_number,1)
for i,idx in enumerate(r_dof):
  F_sol[idx,0] = Fr[i,0]

display(F_sol.applyfunc(sp.N))

###############################################################

vertical_reactions = sp.nsimplify(sp.N(sum(Fr)-Fr[1]))
equilibrium = vertical_reactions + total_load

if abs(equilibrium) == 0:
  print('✅ Se cumple el equilibrio de fuerzas verticales: \n    ∑(Fy) =', equilibrium)
else:
  print('❌ No se cumple el equilibrio de fuerzas verticales: \n    ∑(Fy) =',equilibrium)

#homogeneous ddisplacement field
vh_s = []
colors = plt.cm.Blues([0.4, 0.7, 1])

plt.figure(figsize=(10,5))
plt.title("Homogeneous displacement field")
plt.xlabel("x")
plt.ylabel("W(x)")


deg = 3
for s in range(deg):
  psi2 = E_shapeFunctions[s][0]
  psi3 = E_shapeFunctions[s][1]
  psi5 = E_shapeFunctions[s][2]
  psi6 = E_shapeFunctions[s][3]

  vi = U[element_dof_index[0,:][0]]
  mi = U[element_dof_index[0,:][1]]
  vj = U[element_dof_index[0,:][2]]
  mj = U[element_dof_index[0,:][3]]
  vh_s.append(psi2*vi + psi3*mi + psi5*vj + psi6*mj)

deg = 1
for s in range(deg):
  psi2 = E_shapeFunctions[-1][0]
  psi3 = E_shapeFunctions[-1][1]
  psi5 = E_shapeFunctions[-1][2]
  psi6 = E_shapeFunctions[-1][3]

  vi = U[element_dof_index[-1,:][0]]
  mi = U[element_dof_index[-1,:][1]]
  vj = U[element_dof_index[-1,:][2]]
  mj = U[element_dof_index[-1,:][3]]
  vh_s.append(psi2*vi + psi3*mi + psi5*vj + psi6*mj)


Sym_plot(vh_s[0], 0, 0.25, 30, 0, L=1, E=1, Q=1, color=colors[0])
Sym_plot(vh_s[1], 0.25, 0.75, 30, 0, L=1, E=1, Q=1, color=colors[1])
Sym_plot(vh_s[2], 0.75, 1, 30, 0, L=1, E=1, Q=1, color=colors[2])
Sym_plot(vh_s[3],0,1,30,1,L=1,E=1,Q=1,color = 'magenta')

plt.axvline(x=1, color='k', linestyle='dotted')
plt.axvline(x=2, color='k', linestyle='dotted')
plt.axvline(x=0, color='k', linestyle='dotted')

plt.axvline(x=0.25, color='gray', linestyle='dashed')
plt.axvline(x=0.75, color='gray', linestyle='dashed')

plt.legend(['element 0, sector 0','element 0, sector 1','element 0, sector 2','element 1, sector 0'])

#fixed field
GreenConstants = []

# sector green gonstants:
i1_l,i2_l,i3_l,i4_l = integral_forms[2].subs(x,L)

#sector 0:
i1_x,i2_x,i3_x,i4_x = integral_forms[0]

c2_0 = -i1_x + x*(i2_x+i3_x) - x**2*i4_x
c3_0 = x*i4_x - i3_x
c5_0 = -i1_l + i1_x + x*(i2_l - i2_x - i4_x*(L-x)) + i3_x*(L-x)
c6_0 = x*(i4_l - i4_x) - (i3_l - i3_x)

GreenConstants.append(sp.Matrix([c2_0,c3_0,c5_0,c6_0]))

#sector 1:
i1_x,i2_x,i3_x,i4_x = integral_forms[1]

c2_1 = -i1_x + x*(i2_x+i3_x) - x**2*i4_x
c3_1 = x*i4_x - i3_x
c5_1 = -i1_l + i1_x + x*(i2_l - i2_x - i4_x*(L-x)) + i3_x*(L-x)
c6_1 = x*(i4_l - i4_x) - (i3_l - i3_x)

GreenConstants.append(sp.Matrix([c2_1,c3_1,c5_1,c6_1]))

#sector 2:
i1_x,i2_x,i3_x,i4_x = integral_forms[2]

c2_2 = -i1_x + x*(i2_x+i3_x) - x**2*i4_x
c3_2 = x*i4_x - i3_x
c5_2 = -i1_l + i1_x + x*(i2_l - i2_x - i4_x*(L-x)) + i3_x*(L-x)
c6_2 = x*(i4_l - i4_x) - (i3_l - i3_x)

GreenConstants.append(sp.Matrix([c2_2,c3_2,c5_2,c6_2]))


#sector 3:
i1_l,i2_l,i3_l,i4_l = integral_forms[3].subs(x,L)
i1_x,i2_x,i3_x,i4_x = integral_forms[3]

c2_3 = -i1_x + x*(i2_x+i3_x) - x**2*i4_x
c3_3 = x*i4_x - i3_x
c5_3 = -i1_l + i1_x + x*(i2_l - i2_x - i4_x*(L-x)) + i3_x*(L-x)
c6_3 = x*(i4_l - i4_x) - (i3_l - i3_x)

GreenConstants.append(sp.Matrix([c2_3,c3_3,c5_3,c6_3]))

plt.title('Green constants')
plt.xlabel('x')
plt.ylabel('$C_n(x)$')

Sym_plot(c2_0,0,0.25,30,0,L=1,E=1)
Sym_plot(c3_0,0,0.25,30,0,L=1,E=1)
Sym_plot(c5_0,0,0.25,30,0,L=1,E=1)
Sym_plot(c6_0,0,0.25,30,0,L=1,E=1)

Sym_plot(c2_1,0.25,0.75,30,0,L=1,E=1)
Sym_plot(c3_1,0.25,0.75,30,0,L=1,E=1)
Sym_plot(c5_1,0.25,0.75,30,0,L=1,E=1)
Sym_plot(c6_1,0.25,0.75,30,0,L=1,E=1)

Sym_plot(c2_2,0.75,1,30,0,L=1,E=1)
Sym_plot(c3_2,0.75,1,30,0,L=1,E=1)
Sym_plot(c5_2,0.75,1,30,0,L=1,E=1)
Sym_plot(c6_2,0.75,1,30,0,L=1,E=1)

Sym_plot(c2_3,0,1,30,1,L=1,E=1)
Sym_plot(c3_3,0,1,30,1,L=1,E=1)
Sym_plot(c5_3,0,1,30,1,L=1,E=1)
Sym_plot(c6_3,0,1,30,1,L=1,E=1)

#green functions

#sector 0:
s = 0
gyy1_0 = c2_0*E_shapeFunctions[s][0].subs(x,xi) + c3_0*E_shapeFunctions[s][1].subs(x,xi)
gyy2_0 = c5_0*E_shapeFunctions[s][2].subs(x,xi) + c6_0*E_shapeFunctions[s][3].subs(x,xi)

#sector 1:
s = 1
gyy1_1 = c2_1*E_shapeFunctions[s][0].subs(x,xi) + c3_1*E_shapeFunctions[s][1].subs(x,xi)
gyy2_1 = c5_1*E_shapeFunctions[s][2].subs(x,xi) + c6_1*E_shapeFunctions[s][3].subs(x,xi)

#sector 2:
s = 2
gyy1_2 = c2_2*E_shapeFunctions[s][0].subs(x,xi) + c3_2*E_shapeFunctions[s][1].subs(x,xi)
gyy2_2 = c5_2*E_shapeFunctions[s][2].subs(x,xi) + c6_2*E_shapeFunctions[s][3].subs(x,xi)

#sector 3:
s = 3
gyy1_3 = c2_3*E_shapeFunctions[s][0].subs(x,xi) + c3_3*E_shapeFunctions[s][1].subs(x,xi)
gyy2_3 = c5_3*E_shapeFunctions[s][2].subs(x,xi) + c6_3*E_shapeFunctions[s][3].subs(x,xi)

for p in np.linspace(0,0.25,10):
  Sym_plot(gyy1_0,0,p,30,0,L=1,E=1,xi=p)
  Sym_plot(gyy2_0,p,0.25,30,0,L=1,E=1,xi=p)


for p in np.linspace(0.25,0.75,10):
  Sym_plot(gyy1_1,0.25,p,30,0,L=1,E=1,xi=p)
  Sym_plot(gyy2_1,p,0.75,30,0,L=1,E=1,xi=p)


for p in np.linspace(0.75,1,10):
  Sym_plot(gyy1_2,0.75,p,30,0,L=1,E=1,xi=p)
  Sym_plot(gyy2_2,p,1,30,0,L=1,E=1,xi=p)

# fixed displacement field
#sector 0
wf_0 = sp.integrate(gyy1_1*q1.subs(x,xi),(xi,L/4,3*L/4)) + sp.integrate(gyy1_2*q2.subs(x,xi),(xi,3*L/4,L))


# #sector 3
# wf_31 = sp.integrate(gyy2_3*q3.subs(x,xi),(xi,0,x)) + sp.integrate(gyy1_3*q3.subs(x,xi),(xi,x,L/2))
# wf_32 = sp.integrate(gyy2_3*q3.subs(x,xi),(xi,0,L/2))

xs = np.linspace(0,0.25,30)   # más puntos = más suave
ys = [sp.N(sp.re(wf_0.subs({Q:1,E:1,L:1,x:p}))) for p in xs]
plt.plot(xs, ys,)

xs = np.linspace(0,0.25,30)   # más puntos = más suave
ys = [sp.N(sp.re(wf_0.subs({Q:1,E:1,L:1,x:p}))) for p in xs]
plt.plot(xs, ys,)



xs = np.linspace(0,0.5,30)   # más puntos = más suave
ys = [sp.N(sp.re(wf_31.subs({Q:1,E:1,L:1,x:p}))) for p in xs]
plt.plot(xs+1, ys,)


xs = np.linspace(0.5,1,30)   # más puntos = más suave
ys = [sp.N(sp.re(wf_32.subs({Q:1,E:1,L:1,x:p}))) for p in xs]
plt.plot(xs+1, ys)



from mpl_toolkits.mplot3d import Axes3D
import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

def Sym_surface(expr, x0, xf, Nx, xi0, xif, Nxi, fase=0, color=None, engine="matplotlib", **params):
    # Declaración de variables simbólicas esperadas
    x, xi = sp.symbols('x xi')

    # Convertimos la expresión simbólica → función evaluable
    expr_func = sp.lambdify((x, xi, *params.keys()), expr, 'numpy')

    # Malla de puntos
    x_vals  = np.linspace(x0, xf, Nx)
    xi_vals = np.linspace(xi0, xif, Nxi)
    X, XI = np.meshgrid(x_vals, xi_vals)

    # Se evalúa la función
    Y = expr_func(X, XI, *params.values())

    # ------------------------------------------------------------------
    # 1) PLOT NORMAL (MATPLOTLIB)
    # ------------------------------------------------------------------
    if engine.lower() == "matplotlib":
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')

        ax.plot_surface(X + fase, XI, Y,
                        cmap='viridis' if color is None else None,
                        color=color)

        ax.set_xlabel('x')
        ax.set_ylabel('xi')
        ax.set_zlabel('G(x,xi)')
        ax.set_title('Green Function Surface (matplotlib)')
        plt.show()
        return

    # ------------------------------------------------------------------
    # 2) PLOT INTERACTIVO (PLOTLY)
    # ------------------------------------------------------------------
    elif engine.lower() == "plotly":
        import plotly.graph_objects as go

        fig = go.Figure(data=[go.Surface(x=X+fase, y=XI, z=Y)])
        fig.update_layout(scene=dict(
            xaxis_title='x',
            yaxis_title='xi',
            zaxis_title='G(x,xi)'
        ),
        title="Green Function Surface (plotly)")
        fig.show()
        return

    else:
        raise ValueError("engine debe ser 'matplotlib' o 'plotly'")

Sym_surface(GreenFunctions[0][0], 0, 0.25, 50, 0, 0.25, 50, L=1, E=1, engine="plotly")